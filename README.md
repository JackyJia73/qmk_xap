# Experimental QMK XAP client using Tauri + Vue.js 3

1. Install `69-hid.rules` udev rules https://github.com/libusb/hidapi#hidapi-has-four-back-ends

## Project Structure

```
.
├── public
├── src **Frontend**
│  ├── assets
│  ├── commands (*(not yet) autogenerated* JSON RPC handlers - TS)
│  │  └── lighting
│  ├── layouts (base UI layout)
│  ├── pages (individual XAP subsystem as pages)
│  ├── router (routing for pages)
│  ├── stores (available XAP devices as global state)
│  └── utils
└── src-tauri **Backend**
   ├── bindings (*autogenerated* JSON RPC types)
   ├── icons
   └── src
      ├── commands (*(not yet) autogenerated* JSON RPC handlers - Rust)
      │  └── lighting
      └── xap
         ├── hid (XAP Client and Device abstractions)
         └── protocol (*(not yet) autogenerated* XAP protocol handlers - Rust)
            └── subsystems
               └── lighting
```

### Design "Rules"

**General:**

* Robust error handling
* Leverage types and design APIs that are hard to miss-use

**The Frontend:**

* Is as dumb as possible - it presents data and prepares data to be sent to the backend.
* Holds as little state as possible and rather relies on fetching data from the backend again.
* Reacts to asynchronous Backend events and syncs its internal state accordingly:
  * A new device was found - add it to available devices store
  * A device was removed - remove it from available devices store
  * The secure state of a changed - update secure state of device in the devices store

**The Backend:**

* Handles all low-level USB communication
* Implements and abstracts the XAP protocol
* Handles raw data aggregation and provides normalized abstractions for consumption.
  * When a new Device connects, all static information about the device is retrieved and put into the `XAPDeviceInfo` struct. The frontend works with this struct and e.g. never initiates a query to ask the device about its enabled XAP subsystems.
