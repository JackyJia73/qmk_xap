// This file was generated by xap-specs, do not edit manually

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod xap {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::types::*;
    use crate::xap::spec::xap::*;

    #[tauri::command]
    #[specta::specta]
    pub fn xap_version(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<XapVersionResponse> {
        state
            .lock()
            .query(id, XapVersionRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn xap_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<XapCapabilitiesFlags> {
        state
            .lock()
            .query(id, XapCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn xap_enabled_subsystem_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<XapEnabledSubsystemCapabilitiesFlags> {
        state
            .lock()
            .query(id, XapEnabledSubsystemCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn xap_secure_status(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<XapSecureStatusResponse> {
        state
            .lock()
            .query(id, XapSecureStatusRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn xap_secure_unlock(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<()> {
        state
            .lock()
            .query(id, XapSecureUnlockRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn xap_secure_lock(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<()> {
        state
            .lock()
            .query(id, XapSecureLockRequest(()))
            .map_err(Into::into)
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod qmk {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::qmk::*;
    use crate::xap::spec::types::*;

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_version(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkVersionResponse> {
        state
            .lock()
            .query(id, QmkVersionRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkCapabilitiesFlags> {
        state
            .lock()
            .query(id, QmkCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_board_identifiers(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkBoardIdentifiersResponse> {
        state
            .lock()
            .query(id, QmkBoardIdentifiersRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_board_manufacturer(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkBoardManufacturerResponse> {
        state
            .lock()
            .query(id, QmkBoardManufacturerRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_product_name(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkProductNameResponse> {
        state
            .lock()
            .query(id, QmkProductNameRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_config_blob_length(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkConfigBlobLengthResponse> {
        state
            .lock()
            .query(id, QmkConfigBlobLengthRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_config_blob_chunk(
        id: Uuid,
        arg: u16,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkConfigBlobChunkResponse> {
        state
            .lock()
            .query(id, QmkConfigBlobChunkRequest(arg))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_jump_to_bootloader(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkJumpToBootloaderResponse> {
        state
            .lock()
            .query(id, QmkJumpToBootloaderRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_hardware_identifier(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkHardwareIdentifierResponse> {
        state
            .lock()
            .query(id, QmkHardwareIdentifierRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn qmk_reinitialize_eeprom(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<QmkReinitializeEepromResponse> {
        state
            .lock()
            .query(id, QmkReinitializeEepromRequest(()))
            .map_err(Into::into)
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod keyboard {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::keyboard::*;
    use crate::xap::spec::types::*;
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod user {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::types::*;
    use crate::xap::spec::user::*;
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod keymap {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::keymap::*;
    use crate::xap::spec::types::*;

    #[tauri::command]
    #[specta::specta]
    pub fn keymap_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<KeymapCapabilitiesFlags> {
        state
            .lock()
            .query(id, KeymapCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn keymap_get_layer_count(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<KeymapGetLayerCountResponse> {
        state
            .lock()
            .query(id, KeymapGetLayerCountRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn keymap_get_keycode(
        id: Uuid,
        arg: KeymapGetKeycodeArg,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<KeymapGetKeycodeResponse> {
        state
            .lock()
            .query(id, KeymapGetKeycodeRequest(arg))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn keymap_get_encoder_keycode(
        id: Uuid,
        arg: KeymapGetEncoderKeycodeArg,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<KeymapGetEncoderKeycodeResponse> {
        state
            .lock()
            .query(id, KeymapGetEncoderKeycodeRequest(arg))
            .map_err(Into::into)
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod remapping {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::remapping::*;
    use crate::xap::spec::types::*;

    #[tauri::command]
    #[specta::specta]
    pub fn remapping_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<RemappingCapabilitiesFlags> {
        state
            .lock()
            .query(id, RemappingCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn remapping_get_layer_count(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<RemappingGetLayerCountResponse> {
        state
            .lock()
            .query(id, RemappingGetLayerCountRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn remapping_set_keycode(
        id: Uuid,
        arg: RemappingSetKeycodeArg,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<()> {
        state
            .lock()
            .query(id, RemappingSetKeycodeRequest(arg))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn remapping_set_encoder_keycode(
        id: Uuid,
        arg: RemappingSetEncoderKeycodeArg,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<()> {
        state
            .lock()
            .query(id, RemappingSetEncoderKeycodeRequest(arg))
            .map_err(Into::into)
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod lighting {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::lighting::*;
    use crate::xap::spec::types::*;

    #[tauri::command]
    #[specta::specta]
    pub fn lighting_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<LightingCapabilitiesFlags> {
        state
            .lock()
            .query(id, LightingCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[allow(dead_code)]
    #[allow(unused_imports)]
    pub mod backlight {
        use std::sync::Arc;

        use parking_lot::Mutex;
        use tauri::State;
        use uuid::Uuid;

        use crate::rpc::commands::FrontendResult;
        use crate::xap::client::XapClient;
        use crate::xap::spec::lighting::backlight::*;
        use crate::xap::spec::types::*;

        #[tauri::command]
        #[specta::specta]
        pub fn backlight_capabilities(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<BacklightCapabilitiesFlags> {
            state
                .lock()
                .query(id, BacklightCapabilitiesRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn backlight_get_enabled_effects(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<BacklightGetEnabledEffectsResponse> {
            state
                .lock()
                .query(id, BacklightGetEnabledEffectsRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn backlight_get_config(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<BacklightConfig> {
            state
                .lock()
                .query(id, BacklightGetConfigRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn backlight_set_config(
            id: Uuid,
            arg: BacklightConfig,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<()> {
            state
                .lock()
                .query(id, BacklightSetConfigRequest(arg))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn backlight_save_config(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<()> {
            state
                .lock()
                .query(id, BacklightSaveConfigRequest(()))
                .map_err(Into::into)
        }
    }

    #[allow(dead_code)]
    #[allow(unused_imports)]
    pub mod rgblight {
        use std::sync::Arc;

        use parking_lot::Mutex;
        use tauri::State;
        use uuid::Uuid;

        use crate::rpc::commands::FrontendResult;
        use crate::xap::client::XapClient;
        use crate::xap::spec::lighting::rgblight::*;
        use crate::xap::spec::types::*;

        #[tauri::command]
        #[specta::specta]
        pub fn rgblight_capabilities(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<RgblightCapabilitiesFlags> {
            state
                .lock()
                .query(id, RgblightCapabilitiesRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgblight_get_enabled_effects(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<RgblightGetEnabledEffectsResponse> {
            state
                .lock()
                .query(id, RgblightGetEnabledEffectsRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgblight_get_config(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<RgbLightConfig> {
            state
                .lock()
                .query(id, RgblightGetConfigRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgblight_set_config(
            id: Uuid,
            arg: RgbLightConfig,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<()> {
            state
                .lock()
                .query(id, RgblightSetConfigRequest(arg))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgblight_save_config(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<()> {
            state
                .lock()
                .query(id, RgblightSaveConfigRequest(()))
                .map_err(Into::into)
        }
    }

    #[allow(dead_code)]
    #[allow(unused_imports)]
    pub mod rgbmatrix {
        use std::sync::Arc;

        use parking_lot::Mutex;
        use tauri::State;
        use uuid::Uuid;

        use crate::rpc::commands::FrontendResult;
        use crate::xap::client::XapClient;
        use crate::xap::spec::lighting::rgbmatrix::*;
        use crate::xap::spec::types::*;

        #[tauri::command]
        #[specta::specta]
        pub fn rgbmatrix_capabilities(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<RgbmatrixCapabilitiesFlags> {
            state
                .lock()
                .query(id, RgbmatrixCapabilitiesRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgbmatrix_get_enabled_effects(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<RgbmatrixGetEnabledEffectsResponse> {
            state
                .lock()
                .query(id, RgbmatrixGetEnabledEffectsRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgbmatrix_get_config(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<RgbMatrixConfig> {
            state
                .lock()
                .query(id, RgbmatrixGetConfigRequest(()))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgbmatrix_set_config(
            id: Uuid,
            arg: RgbMatrixConfig,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<()> {
            state
                .lock()
                .query(id, RgbmatrixSetConfigRequest(arg))
                .map_err(Into::into)
        }

        #[tauri::command]
        #[specta::specta]
        pub fn rgbmatrix_save_config(
            id: Uuid,
            state: State<'_, Arc<Mutex<XapClient>>>,
        ) -> FrontendResult<()> {
            state
                .lock()
                .query(id, RgbmatrixSaveConfigRequest(()))
                .map_err(Into::into)
        }
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod audio {
    use std::sync::Arc;

    use parking_lot::Mutex;
    use tauri::State;
    use uuid::Uuid;

    use crate::rpc::commands::FrontendResult;
    use crate::xap::client::XapClient;
    use crate::xap::spec::audio::*;
    use crate::xap::spec::types::*;

    #[tauri::command]
    #[specta::specta]
    pub fn audio_capabilities(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<AudioCapabilitiesFlags> {
        state
            .lock()
            .query(id, AudioCapabilitiesRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn audio_get_config(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<AudioConfig> {
        state
            .lock()
            .query(id, AudioGetConfigRequest(()))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn audio_set_config(
        id: Uuid,
        arg: AudioConfig,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<()> {
        state
            .lock()
            .query(id, AudioSetConfigRequest(arg))
            .map_err(Into::into)
    }

    #[tauri::command]
    #[specta::specta]
    pub fn audio_save_config(
        id: Uuid,
        state: State<'_, Arc<Mutex<XapClient>>>,
    ) -> FrontendResult<()> {
        state
            .lock()
            .query(id, AudioSaveConfigRequest(()))
            .map_err(Into::into)
    }
}

#[macro_export]
macro_rules! generate_specta_builder {
                (commands: [$($command:ident),*], events: [$($event:ident),*]) => {{
                    let specta_builder = tauri_specta::ts::builder()
                        .commands(tauri_specta::collect_commands![
                            crate::rpc::spec::xap::xap_version,
                            crate::rpc::spec::xap::xap_capabilities,
                            crate::rpc::spec::xap::xap_enabled_subsystem_capabilities,
                            crate::rpc::spec::xap::xap_secure_status,
                            crate::rpc::spec::xap::xap_secure_unlock,
                            crate::rpc::spec::xap::xap_secure_lock,
                            crate::rpc::spec::qmk::qmk_version,
                            crate::rpc::spec::qmk::qmk_capabilities,
                            crate::rpc::spec::qmk::qmk_board_identifiers,
                            crate::rpc::spec::qmk::qmk_board_manufacturer,
                            crate::rpc::spec::qmk::qmk_product_name,
                            crate::rpc::spec::qmk::qmk_config_blob_length,
                            crate::rpc::spec::qmk::qmk_config_blob_chunk,
                            crate::rpc::spec::qmk::qmk_jump_to_bootloader,
                            crate::rpc::spec::qmk::qmk_hardware_identifier,
                            crate::rpc::spec::qmk::qmk_reinitialize_eeprom,
                            crate::rpc::spec::keymap::keymap_capabilities,
                            crate::rpc::spec::keymap::keymap_get_layer_count,
                            crate::rpc::spec::keymap::keymap_get_keycode,
                            crate::rpc::spec::keymap::keymap_get_encoder_keycode,
                            crate::rpc::spec::remapping::remapping_capabilities,
                            crate::rpc::spec::remapping::remapping_get_layer_count,
                            crate::rpc::spec::remapping::remapping_set_keycode,
                            crate::rpc::spec::remapping::remapping_set_encoder_keycode,
                            crate::rpc::spec::lighting::lighting_capabilities,
                            crate::rpc::spec::lighting::backlight::backlight_capabilities,
                            crate::rpc::spec::lighting::backlight::backlight_get_enabled_effects,
                            crate::rpc::spec::lighting::backlight::backlight_get_config,
                            crate::rpc::spec::lighting::backlight::backlight_set_config,
                            crate::rpc::spec::lighting::backlight::backlight_save_config,
                            crate::rpc::spec::lighting::rgblight::rgblight_capabilities,
                            crate::rpc::spec::lighting::rgblight::rgblight_get_enabled_effects,
                            crate::rpc::spec::lighting::rgblight::rgblight_get_config,
                            crate::rpc::spec::lighting::rgblight::rgblight_set_config,
                            crate::rpc::spec::lighting::rgblight::rgblight_save_config,
                            crate::rpc::spec::lighting::rgbmatrix::rgbmatrix_capabilities,
                            crate::rpc::spec::lighting::rgbmatrix::rgbmatrix_get_enabled_effects,
                            crate::rpc::spec::lighting::rgbmatrix::rgbmatrix_get_config,
                            crate::rpc::spec::lighting::rgbmatrix::rgbmatrix_set_config,
                            crate::rpc::spec::lighting::rgbmatrix::rgbmatrix_save_config,
                            crate::rpc::spec::audio::audio_capabilities,
                            crate::rpc::spec::audio::audio_get_config,
                            crate::rpc::spec::audio::audio_set_config,
                            crate::rpc::spec::audio::audio_save_config,
                            $($command),*
                        ]).events(tauri_specta::collect_events![$($event),*]);

                    specta_builder
                }};
            }
