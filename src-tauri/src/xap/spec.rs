// This file was generated by xap-specs, do not edit manually

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod xap {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;

    /// ======================================================================
    /// Version
    ///
    /// XAP protocol version query.
    ///
    /// * Returns the BCD-encoded version in the format of XX.YY.ZZZZ => `0xXXYYZZZZ`
    ///     * e.g. 3.2.115 will match `0x03020115`, or bytes {0x15,0x01,0x02,0x03}.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct XapVersionRequest(pub ());

    impl XapRequest for XapVersionRequest {
        type Response = XapVersionResponse;

        fn id() -> &'static [u8] {
            &[0x00, 0x00]
        }

        fn xap_version() -> u32 {
            0x00000001
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct XapVersionResponse(pub u32);

    /// ======================================================================
    ///  capabilities
    ///
    /// XAP subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct XapCapabilitiesRequest(pub ());

    impl XapRequest for XapCapabilitiesRequest {
        type Response = XapCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x00, 0x01]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct XapCapabilitiesFlags(u32);

    bitflags! {
                    impl XapCapabilitiesFlags: u32 {

    const Version = 1 << 0;
    const Capabilities = 1 << 1;
    const EnabledSubsystemCapabilities = 1 << 2;
    const SecureStatus = 1 << 3;
    const SecureUnlock = 1 << 4;
    const SecureLock = 1 << 5;
    }
    }

    /// ======================================================================
    /// Enabled subsystem capabilities
    ///
    /// XAP protocol subsystem query. Each bit should be considered as a "usable" subsystem. For example, checking `(value & (1 << XAP_ROUTE_QMK) != 0)` means the QMK subsystem is enabled and available for querying.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct XapEnabledSubsystemCapabilitiesRequest(pub ());

    impl XapRequest for XapEnabledSubsystemCapabilitiesRequest {
        type Response = XapEnabledSubsystemCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x00, 0x02]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct XapEnabledSubsystemCapabilitiesFlags(u32);

    bitflags! {
                    impl XapEnabledSubsystemCapabilitiesFlags: u32 {

    const Xap = 1 << 0;
    const Qmk = 1 << 1;
    const Keyboard = 1 << 2;
    const User = 1 << 3;
    const Keymap = 1 << 4;
    const Remapping = 1 << 5;
    const Lighting = 1 << 6;
    const Audio = 1 << 7;
    }
    }

    /// ======================================================================
    /// Secure Status
    ///
    /// Query secure route status
    ///
    /// * 0 means secure routes are disabled
    /// * 1 means unlock sequence initiated but incomplete
    /// * 2 means secure routes are allowed
    /// * any other value should be interpreted as disabled
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct XapSecureStatusRequest(pub ());

    impl XapRequest for XapSecureStatusRequest {
        type Response = XapSecureStatusResponse;

        fn id() -> &'static [u8] {
            &[0x00, 0x03]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct XapSecureStatusResponse(pub u8);

    /// ======================================================================
    /// Secure Unlock
    ///
    /// Initiate secure route unlock sequence
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct XapSecureUnlockRequest(pub ());

    impl XapRequest for XapSecureUnlockRequest {
        type Response = ();

        fn id() -> &'static [u8] {
            &[0x00, 0x04]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    /// ======================================================================
    /// Secure Lock
    ///
    /// Disable secure routes
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct XapSecureLockRequest(pub ());

    impl XapRequest for XapSecureLockRequest {
        type Response = ();

        fn id() -> &'static [u8] {
            &[0x00, 0x05]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod qmk {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;

    /// ======================================================================
    /// Version
    ///
    /// QMK protocol version query.
    ///
    /// * Returns the BCD-encoded version in the format of XX.YY.ZZZZ => `0xXXYYZZZZ`
    ///     * e.g. 3.2.115 will match `0x03020115`, or bytes {0x15,0x01,0x02,0x03}.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkVersionRequest(pub ());

    impl XapRequest for QmkVersionRequest {
        type Response = QmkVersionResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x00]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkVersionResponse(pub u32);

    /// ======================================================================
    ///  capabilities
    ///
    /// QMK subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkCapabilitiesRequest(pub ());

    impl XapRequest for QmkCapabilitiesRequest {
        type Response = QmkCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x01, 0x01]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct QmkCapabilitiesFlags(u32);

    bitflags! {
                    impl QmkCapabilitiesFlags: u32 {

    const Version = 1 << 0;
    const Capabilities = 1 << 1;
    const BoardIdentifiers = 1 << 2;
    const BoardManufacturer = 1 << 3;
    const ProductName = 1 << 4;
    const ConfigBlobLength = 1 << 5;
    const ConfigBlobChunk = 1 << 6;
    const JumpToBootloader = 1 << 7;
    const HardwareIdentifier = 1 << 8;
    const ReinitializeEeprom = 1 << 9;
    }
    }

    /// ======================================================================
    /// Board identifiers
    ///
    /// Retrieves the set of identifying information for the board.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkBoardIdentifiersRequest(pub ());

    impl XapRequest for QmkBoardIdentifiersRequest {
        type Response = QmkBoardIdentifiersResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x02]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkBoardIdentifiersResponse {
        pub vendor_id: u16,
        pub product_id: u16,
        pub product_version: u16,
        pub qmk_unique_identifier: u32,
    }

    /// ======================================================================
    /// Board Manufacturer
    ///
    /// Retrieves the name of the manufacturer
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkBoardManufacturerRequest(pub ());

    impl XapRequest for QmkBoardManufacturerRequest {
        type Response = QmkBoardManufacturerResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x03]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkBoardManufacturerResponse(pub UTF8String);

    /// ======================================================================
    /// Product Name
    ///
    /// Retrieves the product name
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkProductNameRequest(pub ());

    impl XapRequest for QmkProductNameRequest {
        type Response = QmkProductNameResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x04]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkProductNameResponse(pub UTF8String);

    /// ======================================================================
    /// Config Blob Length
    ///
    /// Retrieves the length of the configuration data bundled within the firmware
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkConfigBlobLengthRequest(pub ());

    impl XapRequest for QmkConfigBlobLengthRequest {
        type Response = QmkConfigBlobLengthResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x05]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkConfigBlobLengthResponse(pub u16);

    /// ======================================================================
    /// Config Blob Chunk
    ///
    /// Retrieves a chunk of the configuration data bundled within the firmware
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkConfigBlobChunkRequest(pub u16);

    impl XapRequest for QmkConfigBlobChunkRequest {
        type Response = QmkConfigBlobChunkResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x06]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkConfigBlobChunkResponse(pub [u8; 32]);

    /// ======================================================================
    /// Jump to bootloader
    ///
    /// Jump to bootloader
    ///
    /// May not be present - if QMK capabilities query returns “true”, then jump to bootloader is supported
    ///
    /// * 0 means secure routes are disabled, and should be considered as a failure
    /// * 1 means successful, board will jump to bootloader
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkJumpToBootloaderRequest(pub ());

    impl XapRequest for QmkJumpToBootloaderRequest {
        type Response = QmkJumpToBootloaderResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x07]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkJumpToBootloaderResponse(pub u8);

    /// ======================================================================
    /// Hardware Identifier
    ///
    /// Retrieves a unique identifier for the board.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkHardwareIdentifierRequest(pub ());

    impl XapRequest for QmkHardwareIdentifierRequest {
        type Response = QmkHardwareIdentifierResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x08]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkHardwareIdentifierResponse(pub [u32; 4]);

    /// ======================================================================
    /// Reinitialize EEPROM
    ///
    /// Reinitializes the keyboard's EEPROM (persistent memory)
    ///
    /// May not be present - if QMK capabilities query returns “true”, then reinitialize is supported
    ///
    /// * 0 means secure routes are disabled, and should be considered as a failure
    /// * 1 means successful, board will reinitialize and then reboot
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkReinitializeEepromRequest(pub ());

    impl XapRequest for QmkReinitializeEepromRequest {
        type Response = QmkReinitializeEepromResponse;

        fn id() -> &'static [u8] {
            &[0x01, 0x09]
        }

        fn xap_version() -> u32 {
            0x00000100
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct QmkReinitializeEepromResponse(pub u8);
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod keyboard {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod user {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod keymap {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;

    /// ======================================================================
    ///  capabilities
    ///
    /// Keymap subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapCapabilitiesRequest(pub ());

    impl XapRequest for KeymapCapabilitiesRequest {
        type Response = KeymapCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x04, 0x01]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct KeymapCapabilitiesFlags(u32);

    bitflags! {
                    impl KeymapCapabilitiesFlags: u32 {

    const Capabilities = 1 << 1;
    const GetLayerCount = 1 << 2;
    const GetKeycode = 1 << 3;
    const GetEncoderKeycode = 1 << 4;
    }
    }

    /// ======================================================================
    /// Get Layer Count
    ///
    /// Query maximum number of layers that can be addressed within the keymap.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapGetLayerCountRequest(pub ());

    impl XapRequest for KeymapGetLayerCountRequest {
        type Response = KeymapGetLayerCountResponse;

        fn id() -> &'static [u8] {
            &[0x04, 0x02]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapGetLayerCountResponse(pub u8);

    /// ======================================================================
    /// Get Keycode
    ///
    /// Query the Keycode at the requested location.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapGetKeycodeRequest(pub KeymapGetKeycodeArg);

    #[derive(BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct KeymapGetKeycodeArg {
        pub layer: u8,
        pub row: u8,
        pub column: u8,
    }

    impl XapRequest for KeymapGetKeycodeRequest {
        type Response = KeymapGetKeycodeResponse;

        fn id() -> &'static [u8] {
            &[0x04, 0x03]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapGetKeycodeResponse(pub u16);

    /// ======================================================================
    /// Get Encoder Keycode
    ///
    /// Query the Keycode at the requested location.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapGetEncoderKeycodeRequest(pub KeymapGetEncoderKeycodeArg);

    #[derive(BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct KeymapGetEncoderKeycodeArg {
        pub layer: u8,
        pub encoder: u8,
        pub clockwise: u8,
    }

    impl XapRequest for KeymapGetEncoderKeycodeRequest {
        type Response = KeymapGetEncoderKeycodeResponse;

        fn id() -> &'static [u8] {
            &[0x04, 0x04]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct KeymapGetEncoderKeycodeResponse(pub u16);
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod remapping {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;

    /// ======================================================================
    ///  capabilities
    ///
    /// Remapping subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct RemappingCapabilitiesRequest(pub ());

    impl XapRequest for RemappingCapabilitiesRequest {
        type Response = RemappingCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x05, 0x01]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct RemappingCapabilitiesFlags(u32);

    bitflags! {
                    impl RemappingCapabilitiesFlags: u32 {

    const Capabilities = 1 << 1;
    const GetLayerCount = 1 << 2;
    const SetKeycode = 1 << 3;
    const SetEncoderKeycode = 1 << 4;
    }
    }

    /// ======================================================================
    /// Get Layer Count
    ///
    /// Query maximum number of layers that can be addressed within the keymap.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct RemappingGetLayerCountRequest(pub ());

    impl XapRequest for RemappingGetLayerCountRequest {
        type Response = RemappingGetLayerCountResponse;

        fn id() -> &'static [u8] {
            &[0x05, 0x02]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
    pub struct RemappingGetLayerCountResponse(pub u8);

    /// ======================================================================
    /// Set Keycode
    ///
    /// Modify the Keycode at the requested location.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct RemappingSetKeycodeRequest(pub RemappingSetKeycodeArg);

    #[derive(BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct RemappingSetKeycodeArg {
        pub layer: u8,
        pub row: u8,
        pub column: u8,
        pub keycode: u16,
    }

    impl XapRequest for RemappingSetKeycodeRequest {
        type Response = ();

        fn id() -> &'static [u8] {
            &[0x05, 0x03]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    /// ======================================================================
    /// Set Encoder Keycode
    ///
    /// Modify the Keycode at the requested location.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct RemappingSetEncoderKeycodeRequest(pub RemappingSetEncoderKeycodeArg);

    #[derive(BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct RemappingSetEncoderKeycodeArg {
        pub layer: u8,
        pub encoder: u8,
        pub clockwise: u8,
        pub keycode: u16,
    }

    impl XapRequest for RemappingSetEncoderKeycodeRequest {
        type Response = ();

        fn id() -> &'static [u8] {
            &[0x05, 0x04]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod lighting {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;

    /// ======================================================================
    ///  capabilities
    ///
    /// Lighting subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct LightingCapabilitiesRequest(pub ());

    impl XapRequest for LightingCapabilitiesRequest {
        type Response = LightingCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x06, 0x01]
        }

        fn xap_version() -> u32 {
            0x00000200
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct LightingCapabilitiesFlags(u32);

    bitflags! {
                    impl LightingCapabilitiesFlags: u32 {

    const Capabilities = 1 << 1;
    const Backlight = 1 << 2;
    const Rgblight = 1 << 3;
    const Rgbmatrix = 1 << 4;
    }
    }

    #[allow(dead_code)]
    #[allow(unused_imports)]
    pub mod backlight {
        use binrw::{BinRead, BinWrite};
        use bitflags::bitflags;
        use serde::{Deserialize, Serialize};
        use specta::Type;

        use crate::xap::spec::types::*;
        use xap_specs::request::XapRequest;
        use xap_specs::response::UTF8String;

        /// ======================================================================
        ///  capabilities
        ///
        /// backlight subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct BacklightCapabilitiesRequest(pub ());

        impl XapRequest for BacklightCapabilitiesRequest {
            type Response = BacklightCapabilitiesFlags;

            fn id() -> &'static [u8] {
                &[0x06, 0x02, 0x01]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        #[derive(
            BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
        )]
        pub struct BacklightCapabilitiesFlags(u32);

        bitflags! {
                        impl BacklightCapabilitiesFlags: u32 {

        const Capabilities = 1 << 1;
        const GetEnabledEffects = 1 << 2;
        const GetConfig = 1 << 3;
        const SetConfig = 1 << 4;
        const SaveConfig = 1 << 5;
        }
        }

        /// ======================================================================
        /// Get Enabled Effects
        ///
        /// Each bit should be considered as a "usable" effect id
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct BacklightGetEnabledEffectsRequest(pub ());

        impl XapRequest for BacklightGetEnabledEffectsRequest {
            type Response = BacklightGetEnabledEffectsResponse;

            fn id() -> &'static [u8] {
                &[0x06, 0x02, 0x02]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
        pub struct BacklightGetEnabledEffectsResponse(pub u8);

        /// ======================================================================
        /// Get Config
        ///
        /// Query the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct BacklightGetConfigRequest(pub ());

        impl XapRequest for BacklightGetConfigRequest {
            type Response = BacklightConfig;

            fn id() -> &'static [u8] {
                &[0x06, 0x02, 0x03]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        /// ======================================================================
        /// Set Config
        ///
        /// Set the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct BacklightSetConfigRequest(pub BacklightConfig);

        impl XapRequest for BacklightSetConfigRequest {
            type Response = ();

            fn id() -> &'static [u8] {
                &[0x06, 0x02, 0x04]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        /// ======================================================================
        /// Save Config
        ///
        /// Save the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct BacklightSaveConfigRequest(pub ());

        impl XapRequest for BacklightSaveConfigRequest {
            type Response = ();

            fn id() -> &'static [u8] {
                &[0x06, 0x02, 0x05]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }
    }

    #[allow(dead_code)]
    #[allow(unused_imports)]
    pub mod rgblight {
        use binrw::{BinRead, BinWrite};
        use bitflags::bitflags;
        use serde::{Deserialize, Serialize};
        use specta::Type;

        use crate::xap::spec::types::*;
        use xap_specs::request::XapRequest;
        use xap_specs::response::UTF8String;

        /// ======================================================================
        ///  capabilities
        ///
        /// rgblight subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgblightCapabilitiesRequest(pub ());

        impl XapRequest for RgblightCapabilitiesRequest {
            type Response = RgblightCapabilitiesFlags;

            fn id() -> &'static [u8] {
                &[0x06, 0x03, 0x01]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        #[derive(
            BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
        )]
        pub struct RgblightCapabilitiesFlags(u32);

        bitflags! {
                        impl RgblightCapabilitiesFlags: u32 {

        const Capabilities = 1 << 1;
        const GetEnabledEffects = 1 << 2;
        const GetConfig = 1 << 3;
        const SetConfig = 1 << 4;
        const SaveConfig = 1 << 5;
        }
        }

        /// ======================================================================
        /// Get Enabled Effects
        ///
        /// Each bit should be considered as a "usable" effect id
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgblightGetEnabledEffectsRequest(pub ());

        impl XapRequest for RgblightGetEnabledEffectsRequest {
            type Response = RgblightGetEnabledEffectsResponse;

            fn id() -> &'static [u8] {
                &[0x06, 0x03, 0x02]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
        pub struct RgblightGetEnabledEffectsResponse(pub u64);

        /// ======================================================================
        /// Get Config
        ///
        /// Query the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgblightGetConfigRequest(pub ());

        impl XapRequest for RgblightGetConfigRequest {
            type Response = RgbLightConfig;

            fn id() -> &'static [u8] {
                &[0x06, 0x03, 0x03]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        /// ======================================================================
        /// Set Config
        ///
        /// Set the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgblightSetConfigRequest(pub RgbLightConfig);

        impl XapRequest for RgblightSetConfigRequest {
            type Response = ();

            fn id() -> &'static [u8] {
                &[0x06, 0x03, 0x04]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        /// ======================================================================
        /// Save Config
        ///
        /// Save the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgblightSaveConfigRequest(pub ());

        impl XapRequest for RgblightSaveConfigRequest {
            type Response = ();

            fn id() -> &'static [u8] {
                &[0x06, 0x03, 0x05]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }
    }

    #[allow(dead_code)]
    #[allow(unused_imports)]
    pub mod rgbmatrix {
        use binrw::{BinRead, BinWrite};
        use bitflags::bitflags;
        use serde::{Deserialize, Serialize};
        use specta::Type;

        use crate::xap::spec::types::*;
        use xap_specs::request::XapRequest;
        use xap_specs::response::UTF8String;

        /// ======================================================================
        ///  capabilities
        ///
        /// rgb matrix subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgbmatrixCapabilitiesRequest(pub ());

        impl XapRequest for RgbmatrixCapabilitiesRequest {
            type Response = RgbmatrixCapabilitiesFlags;

            fn id() -> &'static [u8] {
                &[0x06, 0x04, 0x01]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        #[derive(
            BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
        )]
        pub struct RgbmatrixCapabilitiesFlags(u32);

        bitflags! {
                        impl RgbmatrixCapabilitiesFlags: u32 {

        const Capabilities = 1 << 1;
        const GetEnabledEffects = 1 << 2;
        const GetConfig = 1 << 3;
        const SetConfig = 1 << 4;
        const SaveConfig = 1 << 5;
        }
        }

        /// ======================================================================
        /// Get Enabled Effects
        ///
        /// Each bit should be considered as a "usable" effect id
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgbmatrixGetEnabledEffectsRequest(pub ());

        impl XapRequest for RgbmatrixGetEnabledEffectsRequest {
            type Response = RgbmatrixGetEnabledEffectsResponse;

            fn id() -> &'static [u8] {
                &[0x06, 0x04, 0x02]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        #[derive(BinRead, Default, Debug, Clone, Serialize, Type)]
        pub struct RgbmatrixGetEnabledEffectsResponse(pub u64);

        /// ======================================================================
        /// Get Config
        ///
        /// Query the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgbmatrixGetConfigRequest(pub ());

        impl XapRequest for RgbmatrixGetConfigRequest {
            type Response = RgbMatrixConfig;

            fn id() -> &'static [u8] {
                &[0x06, 0x04, 0x03]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        /// ======================================================================
        /// Set Config
        ///
        /// Set the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgbmatrixSetConfigRequest(pub RgbMatrixConfig);

        impl XapRequest for RgbmatrixSetConfigRequest {
            type Response = ();

            fn id() -> &'static [u8] {
                &[0x06, 0x04, 0x04]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }

        /// ======================================================================
        /// Save Config
        ///
        /// Save the current config.
        /// ======================================================================
        #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
        pub struct RgbmatrixSaveConfigRequest(pub ());

        impl XapRequest for RgbmatrixSaveConfigRequest {
            type Response = ();

            fn id() -> &'static [u8] {
                &[0x06, 0x04, 0x05]
            }

            fn xap_version() -> u32 {
                0x00000300
            }
        }
    }
}

#[allow(dead_code)]
#[allow(unused_imports)]
pub mod audio {
    use binrw::{BinRead, BinWrite};
    use bitflags::bitflags;
    use serde::{Deserialize, Serialize};
    use specta::Type;

    use crate::xap::spec::types::*;
    use xap_specs::request::XapRequest;
    use xap_specs::response::UTF8String;

    /// ======================================================================
    ///  capabilities
    ///
    /// Audio subsystem capabilities query. Each bit should be considered as a "usable" route within this subsystem.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct AudioCapabilitiesRequest(pub ());

    impl XapRequest for AudioCapabilitiesRequest {
        type Response = AudioCapabilitiesFlags;

        fn id() -> &'static [u8] {
            &[0x07, 0x01]
        }

        fn xap_version() -> u32 {
            0x00000300
        }
    }

    #[derive(
        BinRead, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy, Serialize, Type,
    )]
    pub struct AudioCapabilitiesFlags(u32);

    bitflags! {
                    impl AudioCapabilitiesFlags: u32 {

    const Capabilities = 1 << 1;
    const GetConfig = 1 << 3;
    const SetConfig = 1 << 4;
    const SaveConfig = 1 << 5;
    }
    }

    /// ======================================================================
    /// Get Config
    ///
    /// Query the current config.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct AudioGetConfigRequest(pub ());

    impl XapRequest for AudioGetConfigRequest {
        type Response = AudioConfig;

        fn id() -> &'static [u8] {
            &[0x07, 0x03]
        }

        fn xap_version() -> u32 {
            0x00000300
        }
    }

    /// ======================================================================
    /// Set Config
    ///
    /// Set the current config.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct AudioSetConfigRequest(pub AudioConfig);

    impl XapRequest for AudioSetConfigRequest {
        type Response = ();

        fn id() -> &'static [u8] {
            &[0x07, 0x04]
        }

        fn xap_version() -> u32 {
            0x00000300
        }
    }

    /// ======================================================================
    /// Save Config
    ///
    /// Save the current config.
    /// ======================================================================
    #[derive(BinWrite, Default, Debug, Clone, Serialize, Type)]
    pub struct AudioSaveConfigRequest(pub ());

    impl XapRequest for AudioSaveConfigRequest {
        type Response = ();

        fn id() -> &'static [u8] {
            &[0x07, 0x05]
        }

        fn xap_version() -> u32 {
            0x00000300
        }
    }
}

pub mod types {
    use binrw::{BinRead, BinWrite};
    use serde::{Deserialize, Serialize};
    use specta::Type;

    /// RGB config for RGB matrix subsystem
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct RgbMatrixConfig {
        pub enable: u8,
        pub mode: u8,
        pub hue: u8,
        pub sat: u8,
        pub val: u8,
        pub speed: u8,
        pub flags: u8,
    }

    /// Packet format for broadcast messages.
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct BroadcastHeader {
        pub r#type: u8,
        pub length: u8,
    }

    /// Config for audio subsystem
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct AudioConfig {
        pub enable: u8,
        pub clicky_enable: u8,
    }

    /// Packet format for outbound data.
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct ResponseHeader {
        pub length: u8,
    }

    /// Packet format for inbound data.
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct RequestHeader {
        pub length: u8,
    }

    /// RGB config for RGB lighting subsystem
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct RgbLightConfig {
        pub enable: u8,
        pub mode: u8,
        pub hue: u8,
        pub sat: u8,
        pub val: u8,
        pub speed: u8,
    }

    /// Config for lighting subsystem
    #[derive(BinRead, BinWrite, Default, Debug, Clone, Serialize, Deserialize, Type)]
    pub struct BacklightConfig {
        pub enable: u8,
        pub mode: u8,
        pub val: u8,
    }
}
